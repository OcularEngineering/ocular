import * as path from 'path';
import { TransactionBaseService } from "./transaction-base-service";
import { SearchIndexClient, QueryType } from "@azure/search-documents"
import {SearchClient,ExtractiveQueryCaption} from "@azure/search-documents"
import { AutoflowContainer, IndexableDocument } from "../common";
import { AutoflowAiError } from "@ocular-ai/utils";
import { ConfigModule } from "../config";

// import { ExtractiveQueryAnswer } from "@azure/search-documents";

export class ThoughtStep {
  title: string;
  description: any | null;
  props: { [key: string]: any } | null;

  constructor(title: string, description: any | null, props: { [key: string]: any } | null = null) {
      this.title = title;
      this.description = description;
      this.props = props;
  }
}

export interface ISearchApproach extends TransactionBaseService {
  /**
   * Executes the search approach
   */
  run(
    messages: Array<{ [key: string]: any }>, 
    stream: boolean, 
    sessionState: any | null, 
    context: { [key: string]: any },
  ): Promise<{ [key: string]: any }>
}

export type VectorQuery = {
  vector: string;
  kNearestNeighbors: number;
  fields: Array<string>;
};

export type SearchOptions = {
  top: number;
  queryText?: string;
  filter: string;
  queryVector: string;
  useSemanticRanker: boolean;
  useSemanticCaptions: boolean;
};

export type SearchResults = {
  id: string;
  content: string;
  embedding: string;
  imageEmbedding: string;
  category: string;
  sourcepage: string;
  sourcefile: string;
  oids: string;
  groups: string;
  captions: string;
};

export abstract class AbstactSearchApproach extends TransactionBaseService implements ISearchApproach
{
  static identifier: string;
  static _isSearchApproach = true;
  // protected abstract searchClient_: SearchClient<IndexableDocument>
  protected readonly searchIndexClient_: SearchIndexClient


  static isSearchApproach(object): object is ISearchApproach {
    return object?.constructor?._isSearchApproach
  }

  protected constructor(
    protected readonly container: Record<string, unknown>,
    protected readonly config?: Record<string, unknown> // eslint-disable-next-line @typescript-eslint/no-empty-function
  ) {
    super(container, config)
  }

  async search(searchClient: SearchClient<IndexableDocument>, options: SearchOptions): Promise<Array<IndexableDocument>> {

    // Semantic Hybrid Search
    const searchResults = await searchClient.search(options.queryText, {
      vectorSearchOptions: {
        queries: [
          {
            vector: [],
            kind: 'vector',
            kNearestNeighborsCount: 50,
            fields: ["title"],
          },
        ],
      },
      select: ["title", "content",],
      queryType: "semantic",
      top: options.top,
      semanticSearchOptions: {
        answers: {
          answerType: "extractive",
          count: 3
        },
        captions:{
          captionType: "extractive",
        },
        // Adjust these properties to match your needs
      },
    });

 

    for await (const answer of searchResults.answers) {
      if (answer.highlights) {
        console.log(`Semantic answer: ${answer.highlights}`);
      } else {
        console.log(`Semantic answer: ${answer.text}`);
      }
  
      console.log(`Semantic answer score: ${answer.score}\n`);
    }
  
    for await (const result of searchResults.results) {
      console.log(`Title: ${result.document.title}`);
      console.log(`Reranker Score: ${result.rerankerScore}`); // Reranker score is the semantic score
      console.log(`Content: ${result.document.content}`);
      // console.log(`Category: ${result.document.category}`);
  
      if (result.captions) {
        const caption = result.captions[0];
        if (caption.highlights) {
          console.log(`Caption: ${caption.highlights}`);
        } else {
          console.log(`Caption: ${caption.text}`);
        }
      }
      console.log(`\n`);
    }

       // let documents = [];
    // for await (let page of searchResults.results) {
    //         documents.push({
    //             id: document['id'],
    //             content: document['content'],
    //             embedding: document['embedding'],
    //             category: document['category'],
    //             sourcepage: document['sourcepage'],
    //             sourcefile: document['sourcefile'],
    //             oids: document['oids'],
    //             groups: document['groups'],
    //             captions: document['@search.captions'],
    //         });
    // }
    // return documents;
    // return null
  }

  // async getSourcesContent(results:Array<IndexableDocument>, useSemanticCaptions: Boolean) {
  //   if (useSemanticCaptions) {
  //       return results.map(doc => 
  //           `${this.getCitation(doc.sourcepage || "", useImageCitation)}: ${
  //               this.nonewlines((doc.captions || []).map(c => String(c.text)).join(" . "))
  //           }`
  //       );
  //   } else {
  //       return results.map(doc => 
  //           `${this.getCitation(doc.sourcepage || "", useImageCitation)}: ${
  //               this.nonewlines(doc.content || "")
  //           }`
  //       );
  //   }
  // }

  // splitExt(filePath: string): [string, string] {
  //   let base = filePath.slice(0, filePath.lastIndexOf('.'));
  //   let ext = filePath.slice(filePath.lastIndexOf('.'));
  //   return [base, ext];
  // }

  // getCitation(sourcepage: string, useImageCitation: boolean): string {
  //   if (useImageCitation) {
  //       return sourcepage;
  //   } else {
  //       let [path, ext] = splitExt(sourcepage);
  //       if (ext.toLowerCase() === ".png") {
  //           let pageIdx = path.lastIndexOf("-");
  //           let pageNumber = parseInt(path.slice(pageIdx + 1));
  //           return `${path.slice(0, pageIdx)}.pdf#page=${pageNumber}`;
  //       }
  //       return sourcepage;
  //   }
  // }

  // async computeTextEmbedding(q: string) {
  //   const embedding = await this.openaiClient.embeddings.create({
  //       // Azure Open AI takes the deployment name as the model name
  //       model: this.embeddingDeployment ? this.embeddingDeployment : this.embeddingModel,
  //       input: q,
  //   });
  //   const queryVector = embedding.data[0].embedding;
  //   return VectorizedQuery({ vector: queryVector, kNearestNeighbors: 50, fields: ['title'] });
  // }

  async run(
    messages: Array<{ [key: string]: any }>, 
    stream: boolean = false, 
    sessionState: any = null, 
    context: { [key: string]: any } = {}
  ): Promise<{ [key: string]: any }> {
    throw new Error("Not implemented");
  }

  private nonewlines(s: string): string {
    return s.replace(/\n/g, " ").replace(/\r/g, " ");
  }

  private splitext(p: string | Buffer): [string, string] {
    let sep: string | Buffer = '/';
    let extsep: string | Buffer = '.';

    if (Buffer.isBuffer(p)) {
        sep = Buffer.from('/');
        extsep = Buffer.from('.');
    }

    const ext = path.extname(p.toString());
    const filename = path.basename(p.toString(), ext);

    return [filename, ext];
  }
}