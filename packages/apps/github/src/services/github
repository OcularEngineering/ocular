import { Readable } from 'stream';
import { EntityManager } from "typeorm";
import { Octokit } from "@octokit/rest";
import { OAuthService, Organisation } from "@ocular-ai/core-backend";
import { IndexableDocument, TransactionBaseService, Logger, AppNameDefinitions  } from "@ocular-ai/types";
// import { AutoflowAiError } from "@ocular-ai/utils";

class GitHubService extends TransactionBaseService {
  protected oauthService_: typeof OAuthService;
  protected logger_: Logger;

  constructor(container) {
    super(arguments[0]);
    this.oauthService_ = container.oauthService;
    this.logger_ = container.logger;
  }


  async getRepositoriesOcular(organisation: Organisation) {
    return Readable.from(this.getGitHubRepositories(organisation));
  }

  async *getGitHubRepositories(org: Organisation): AsyncGenerator<IndexableDocument> {
    // return await this.atomicPhase_(
    //   async (transactionManager: EntityManager) => {
    //     this.logger_.info(`Starting oculation of core users for ${org.id} organisation`);

    //     //Get Github Oauth Credentials for this Organisation
    //     //Should Be Done In PreProcessing Phase of the Job 
    //     // If Credentials are expired use Oauth Service to refresh the credentials
    //     // Should be done it the PreProcessing Phase of the Job.
    //     const githubCredentials = this.oauthService_.retrieve({id: org.id, app_name: AppNameDefinitions.GITHUB})
    //     if (!githubCredentials) {
    //       throw new AutoflowAiError(
    //         AutoflowAiError.Types.NOT_FOUND,
    //         `No credentials found for organisation ${org.id}`
    //       )
    //     }

    //     const octokit = new Octokit({
    //       auth: 'your-github-token', // replace 'your-github-token' with your actual GitHub token
    //     });

    //     const iterator = octokit.paginate.iterator(octokit.rest.repos.listForOrg, {
    //     "org",
    //       type: 'private',
    //     });



    //   for await (const { data: repos } of iterator) {
    //     for (const repo of repos) {
          
    //       // const repositories = repositoriesFromGithub.map(r => {
    //       //   return {
    //       //     url: r.url,
    //       //     name: r.name,
    //       //     defaultBranchRef: r.defaultBranchRef?.name,
    //       //     repositoryTopics: r.repositoryTopics.nodes.map(t => t.topic.name),
    //       //     isArchived: r.isArchived,
    //       //     isFork: r.isFork,
    //       //     isCatalogInfoFilePresent:
    //       //       r.catalogInfoFile?.__typename === 'Blob' &&
    //       //       r.catalogInfoFile.text !== '',
    //       //     visibility: r.visibility,
    //       //   };
    //       // });
    //     //   yield { 
    //     //     id: user.id,
    //     //     organisation_id: organisation.id,
    //     //     title: user.first_name + " " + user.last_name,
    //     //     source: AppType.CORE_BACKEND,
    //     //     content: [
    //     //       { text: user.email},
    //     //     ],
    //     //     updated_at: user.updated_at,
    //     //     location: "https://example.com",
    //     // }

    //     }
    //   }
    //   this.logger_.info('Finished oculation of core users');
    // })
  }

}
